---
title: "Parallel Computing with R"
subtitle: Write a parallel for loop
week: 11
type: Case Study
reading:
   - Parallel [Computing with the R Language in a Supercomputing Environment](https://link.springer.com/chapter/10.1007/978-3-642-13872-0_64)
   - CRAN Task View [High Performance and Parallel Computing with R](http://cran.r-project.org/web/views/HighPerformanceComputing.html)
tasks:
   - Reproject `world` dataset to a global equal area projection
   - Write a parallel `foreach()` loop to identify the a spatial relationships of each country
   - Set the output of the `foreach()` funtion to return a simple matrix
   - Confirm that your parallel loop returns the same answer as a typical "sequential" approach
---

```{r setup, include=FALSE, purl=F}
source("functions.R")
source("knitr_header.R")
library(knitr)
```

# Reading

```{r reading,results='asis',echo=F,purl=F}
md_bullet(rmarkdown::metadata$reading)
```


# Tasks

```{r tasks,results='asis',echo=F, purl=F}
md_bullet(rmarkdown::metadata$tasks)
```

## Background

```{r cache=F, message=F,warning=FALSE, results='hide'}
library(tidyverse)
library(spData)
library(sf)

## New Packages
library(foreach)
library(doParallel)
registerDoParallel(2)
getDoParWorkers() # check registered cores

#define working projection (EASE-Grid, https://nsidc.org/data/ease)
proj="+proj=cea +lon_0=0 +lat_ts=30 +x_0=0 +y_0=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
```

<div class="well">
<button data-toggle="collapse" class="btn btn-primary btn-sm round" data-target="#demo1">Show Hints</button>
<div id="demo1" class="collapse">

## Steps

Write an Rmd script that:

* Loads the `world` dataset in the `spData` package
   * Reproject the `world` dataset to the Equal-Area Scalable Earth Grid (EASE-Grid) ([EASE-Grid ](https://nsidc.org/data/ease)) using `st_transform()` and the proj4 projection in the code above
* Runs a parallel `foreach()` to loop over countries (`name_long`) that:
   * `filter` the world object to include only on country at a time.
   * use `st_is_within_distance` to find the distance from that country to all other countries in the `world` object within 100000m Set `sparse=F` to return a simple vector of `TRUE/FALSE` for countries within the distance.
   * set `.combine=rbind` to return a simple matrix.
* Confirm that you get the same answer without using foreach:
   * simply use `st_is_within_distance` with the transformed `world` object as both `x` and `y` object.
   * compare the results with `identical()`
   * if you are curious, you can also check the time difference with `system.time()`.
   
   
</div>
</div>

```{r, echo=F, purl=F}
data("world")
dist=100000 # distance in m
world2=st_transform(world,proj)

#system.time(
  x_seq <- world2%>%
  st_is_within_distance(world2,dist,sparse=F)
#)

#system.time(
  x_par <- foreach(i=unique(world$name_long),.combine=rbind) %dopar% {
  world2%>%
    filter(name_long==i)%>%
    st_is_within_distance(world2,dist=dist,sparse = F)
  }
#)
#identical(x_seq,x_par)
```

The first 10 rows/columns of the resulting matrix (e.g. `x_par[1:10,1:10]`) should look like this:
```{r, purl=F, echo=F}
x_par[1:10,1:10]%>%kable(col.names = 1:10)
```

Note that in this example the sequential version typically runs faster than the parallel version due to the relatively small size of the dataset and computation needed.


---

<div class="extraswell">
<button data-toggle="collapse" class="btn btn-link" data-target="#extras">
Extra time? Try this...
</button>
<div id="extras" class="collapse">

This approach could be used to identify which countries were 'close' to others.  For example, Identify which countries are within `r dist`m of Costa Rica:

```{r purl=F, echo=F}
i=which(world2$name_long=="Costa Rica")
# neighbor countries
world2[x_par[i,],]$name_long%>% kable(col.names="Nearbye Countries")
```

And plot them:

```{r echo=F, purl=F, fig.height=7}
ggplot()+
  geom_sf(data=world2[x_par[i,],])+
  geom_sf(data=world2[i,],col="red")
```

</div>
</div>
