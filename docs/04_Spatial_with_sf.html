<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Working with Spatial Data</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">GEO 503: Spatial Data Science</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="Syllabus.html">Syllabus</a>
</li>
<li>
  <a href="Schedule.html">Schedule</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Content
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="CourseContent.html">About Course Content</a>
    </li>
    <li class="dropdown-header">Module 1: Introduction to R</li>
    <li>
      <a href="00_CourseIntroductionFrame.html">00 Course Introduction</a>
    </li>
    <li>
      <a href="01_Rintro.html">01 First Steps</a>
    </li>
    <li>
      <a href="02_graphics.html">02 Graphics</a>
    </li>
    <li>
      <a href="03_DataWrangling.html">03 Data Wrangling</a>
    </li>
    <li>
      <a href="03b_DataWrangling.html">03 Data Wrangling 2</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Module 2: Spatial Analyses</li>
    <li>
      <a href="04_Spatial_with_sf.html">04 Spatial Data with sf</a>
    </li>
    <li>
      <a href="05_Raster.html">05 Spatial Raster Data</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Module 3: Advanced Programming</li>
    <li>
      <a href="06_CreatingWorkflows.html">06 Creating Workflows</a>
    </li>
    <li>
      <a href="07_Reproducibile.html">07 Reproducible Research</a>
    </li>
    <li>
      <a href="08_WeatherData.html">08 Weather Data Processing</a>
    </li>
    <li>
      <a href="09_RemoteSensing_appeears.html">09 Satellite Data Processing</a>
    </li>
    <li>
      <a href="11_ParallelProcessing.html">11 Parallel Processing</a>
    </li>
    <li>
      <a href="12_DynamicVisualization.html">12 Dynamic Visualization</a>
    </li>
    <li>
      <a href="13_SDM_Exercise.html">13 Species Distribution Modeling</a>
    </li>
    <li class="divider"></li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Assignments
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Tasklist.html">Task list</a>
    </li>
    <li>
      <a href="DataCamp.html">DataCamp</a>
    </li>
    <li>
      <a href="PackageIntro.html">Package Introduction</a>
    </li>
    <li>
      <a href="Project.html">Final Project</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Resources
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Provenance.html">Provenance</a>
    </li>
    <li>
      <a href="Projects_2017.html">2017 Final Projects</a>
    </li>
    <li>
      <a href="Resources.html">Resources</a>
    </li>
    <li>
      <a href="GitSSHNotes.html">Setting up Github</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/adammwilson/RDataScience">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Working with Spatial Data</h1>

</div>


<div>
<iframe src="04_assets/04_Presentation.html" width="100%" height="400px">
</iframe>
<p><a href="scripts/04_Spatial_with_sf.R"><i class="fa fa-file-code-o fa-3x" aria-hidden="true"></i> The R Script associated with this page is available here</a>. Download this file and open it (or copy-paste into a new script) with RStudio so you can follow along.</p>
<div id="setup" class="section level1">
<h1>Setup</h1>
<p>You may need to install a few of these packages with <code>install.packages()</code> or using the GUI. Note, much of the material below was taken from the <a href="https://cran.r-project.org/web/packages/sf/vignettes">sf vignettes available here</a>.</p>
<div id="load-packages" class="section level2">
<h2>Load packages</h2>
<pre class="r"><code>library(rgdal)
library(rgeos)
library(sf)
library(ggplot2)
library(dplyr)
library(tidyr)
library(maptools)</code></pre>
</div>
</div>
<div id="background" class="section level1">
<h1>Background</h1>
<p>There are currently two main approaches in R to handle geographic vector data.</p>
<div id="the-sp-package" class="section level2">
<h2>The <code>sp</code> package</h2>
<p>The first package to provide classes and methods for spatial data types in R is called <a href="https://cran.r-project.org/package=sp"><code>sp</code></a><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. Development of the <code>sp</code> package began in the early 2000s in an attempt to standardize how spatial data would be treated in R and to allow for better interoperability between different analysis packages that use spatial data. The package (first release on CRAN in 2005) provides classes and methods to create <em>points</em>, <em>lines</em>, <em>polygons</em>, and <em>grids</em> and to operate on them. About 350 of the spatial analysis packages use the spatial data types that are implemented in <code>sp</code> i.e. they “depend” on the <code>sp</code> package and many more are indirectly dependent.</p>
<p>The foundational structure for any spatial object in <code>sp</code> is the <code>Spatial</code> class. It has two “slots” (<a href="http://stackoverflow.com/a/4714080">new-style S4 class objects in R have pre-defined components called slots</a>):</p>
<ul>
<li><p>a <strong>bounding box</strong></p></li>
<li><p>a <strong>CRS class object</strong> to define the Coordinate Reference System</p></li>
</ul>
<p>This basic structure is then extended, depending on the characteristics of the spatial object (point, line, polygon).</p>
<p>To build up a spatial object in <code>sp</code> we could follow these steps:</p>
<div id="i.-create-geometric-objects-topology" class="section level3">
<h3>I. Create geometric objects (topology)</h3>
<p><strong>Points</strong> (which may have 2 or 3 dimensions) are the most basic spatial data objects. They are generated out of either a single coordinate or a set of coordinates, like a two-column matrix or a dataframe with a column for latitude and one for longitude.<br />
<strong>Lines</strong> are generated out of <code>Line</code> objects. A <code>Line</code> object is a spaghetti collection of 2D coordinates<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> and is generated out of a two-column matrix or a dataframe with a column for latitude and one for longitude. A <code>Lines</code> object is a <strong>list</strong> of one or more <code>Line</code> objects, for example all the contours at a single elevation.<br />
<strong>Polygons</strong> are generated out of <code>Polygon</code> objects. A <code>Polygon</code> object is a spaghetti collection of 2D coordinates with equal first and last coordinates and is generated out of a two-column matrix or a dataframe with a column for latitude and one for longitude. A <code>Polygons</code> object is a <strong>list</strong> of one or more <code>Polygon</code> objects, for example islands belonging to the same country.</p>
<p>See here for a very simple example for how to create a <code>Line</code> object:</p>
<pre class="r"><code>ln &lt;- Line(matrix(runif(6), ncol=2))
str(ln)</code></pre>
<pre><code>## Formal class &#39;Line&#39; [package &quot;sp&quot;] with 1 slot
##   ..@ coords: num [1:3, 1:2] 0.409 0.663 0.971 0.293 0.988 ...</code></pre>
<p>See here for a very simple example for how to create a <code>Lines</code> object:</p>
<pre class="r"><code>lns &lt;- Lines(list(ln), ID = &quot;a&quot;) # this contains just one Line!
str(lns)</code></pre>
<pre><code>## Formal class &#39;Lines&#39; [package &quot;sp&quot;] with 2 slots
##   ..@ Lines:List of 1
##   .. ..$ :Formal class &#39;Line&#39; [package &quot;sp&quot;] with 1 slot
##   .. .. .. ..@ coords: num [1:3, 1:2] 0.409 0.663 0.971 0.293 0.988 ...
##   ..@ ID   : chr &quot;a&quot;</code></pre>
</div>
<div id="ii.-create-spatial-objects-spatial-object-stands-for-points-lines-or-polygons." class="section level3">
<h3>II. Create spatial objects <code>Spatial*</code> object (<code>*</code> stands for Points, Lines, or Polygons).</h3>
<p>This step adds the bounding box (automatically) and the slot for the Coordinate Reference System or CRS (which needs to be filled with a value manually). <code>SpatialPoints</code> can be directly generated out of the coordinates. <code>SpatialLines</code> and <code>SpatialPolygons</code> objects are generated using lists of <code>Lines</code> or <code>Polygons</code> objects respectively (more below).</p>
<p>See here for how to create a <code>SpatialLines</code> object:</p>
<pre class="r"><code>sp_lns &lt;- SpatialLines(list(lns))
str(sp_lns)</code></pre>
<pre><code>## Formal class &#39;SpatialLines&#39; [package &quot;sp&quot;] with 3 slots
##   ..@ lines      :List of 1
##   .. ..$ :Formal class &#39;Lines&#39; [package &quot;sp&quot;] with 2 slots
##   .. .. .. ..@ Lines:List of 1
##   .. .. .. .. ..$ :Formal class &#39;Line&#39; [package &quot;sp&quot;] with 1 slot
##   .. .. .. .. .. .. ..@ coords: num [1:3, 1:2] 0.409 0.663 0.971 0.293 0.988 ...
##   .. .. .. ..@ ID   : chr &quot;a&quot;
##   ..@ bbox       : num [1:2, 1:2] 0.40923 0.00417 0.97139 0.98836
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
##   .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot;
##   ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot
##   .. .. ..@ projargs: chr NA</code></pre>
</div>
<div id="iii.-add-attributes-optional" class="section level3">
<h3>III. Add attributes (<em>Optional</em>:)</h3>
<p>Add a data frame with attribute data, which will turn your <code>Spatial*</code> object into a <code>Spatial*DataFrame</code> object. The points in a <code>SpatialPoints</code> object may be associated with a row of attributes to create a <code>SpatialPointsDataFrame</code> object. The coordinates and attributes may, but do not have to be keyed to each other using ID values.<br />
<code>SpatialLinesDataFrame</code> and <code>SpatialPolygonsDataFrame</code> objects are defined using <code>SpatialLines</code> and <code>SpatialPolygons</code> objects and data frames. The ID fields are here required to match the data frame row names.</p>
<p>See here for how to create a <code>SpatialLinesDataframe</code>:</p>
<pre class="r"><code>dfr &lt;- data.frame(id = &quot;a&quot;, use = &quot;road&quot;, cars_per_hour = 10) # note how we use the ID from above!
sp_lns_dfr &lt;- SpatialLinesDataFrame(sp_lns, dfr, match.ID = &quot;id&quot;)
str(sp_lns_dfr)</code></pre>
<pre><code>## Formal class &#39;SpatialLinesDataFrame&#39; [package &quot;sp&quot;] with 4 slots
##   ..@ data       :&#39;data.frame&#39;:  1 obs. of  3 variables:
##   .. ..$ id           : Factor w/ 1 level &quot;a&quot;: 1
##   .. ..$ use          : Factor w/ 1 level &quot;road&quot;: 1
##   .. ..$ cars_per_hour: num 10
##   ..@ lines      :List of 1
##   .. ..$ :Formal class &#39;Lines&#39; [package &quot;sp&quot;] with 2 slots
##   .. .. .. ..@ Lines:List of 1
##   .. .. .. .. ..$ :Formal class &#39;Line&#39; [package &quot;sp&quot;] with 1 slot
##   .. .. .. .. .. .. ..@ coords: num [1:3, 1:2] 0.409 0.663 0.971 0.293 0.988 ...
##   .. .. .. ..@ ID   : chr &quot;a&quot;
##   ..@ bbox       : num [1:2, 1:2] 0.40923 0.00417 0.97139 0.98836
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
##   .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot;
##   ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot
##   .. .. ..@ projargs: chr NA</code></pre>
<p>A number of spatial methods are available for the classes in <code>sp</code>. Common ones include:</p>
<table>
<colgroup>
<col width="18%" />
<col width="81%" />
</colgroup>
<thead>
<tr class="header">
<th>function</th>
<th>and what it does</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bbox()</code></td>
<td>returns the bounding box coordinates</td>
</tr>
<tr class="even">
<td><code>proj4string()</code></td>
<td>sets or retrieves projection attributes using the CRS object.</td>
</tr>
<tr class="odd">
<td><code>CRS()</code></td>
<td>creates an object of class of coordinate reference system arguments</td>
</tr>
<tr class="even">
<td><code>spplot()</code></td>
<td>plots a separate map of all the attributes unless specified otherwise</td>
</tr>
<tr class="odd">
<td><code>coordinates()</code></td>
<td>set or retrieve the spatial coordinates. For spatial polygons it returns the centroids.</td>
</tr>
<tr class="even">
<td><code>over(a, b)</code></td>
<td>used for example to retrieve the polygon or grid indices on a set of points</td>
</tr>
<tr class="odd">
<td><code>spsample()</code></td>
<td>sampling of spatial points within the spatial extent of objects</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="the-sf-package" class="section level2">
<h2>The <code>sf</code> package</h2>
<p>The second package, first released on CRAN in late October 2016, is called <a href="https://cran.r-project.org/package=sf"><code>sf</code></a><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. It implements a formal standard called <a href="https://en.wikipedia.org/wiki/Simple_Features">“Simple Features”</a> that specifies a storage and access model of spatial geometries (point, line, polygon). A feature geometry is called simple when it consists of points connected by straight line pieces, and does not intersect itself. This standard has been adopted widely, not only by spatial databases such as PostGIS, but also more recent standards such as GeoJSON.</p>
<p><a href="https://en.wikipedia.org/wiki/Simple_Features">Simple features</a> or <a href="http://www.opengeospatial.org/standards/sfa"><em>simple feature access</em></a> refers to a formal standard (ISO 19125-1:2004) that describes how objects in the real world can be represented in computers, with emphasis on the <em>spatial</em> geometry of these objects. It also describes how such objects can be stored in and retrieved from databases, and which geometrical operations should be defined for them.</p>
<p>The standard is widely implemented in spatial databases (such as PostGIS), commercial GIS (e.g., <a href="http://www.esri.com/">ESRI ArcGIS</a>) and forms the vector data basis for libraries such as <a href="http://www.gdal.org/">GDAL</a>. A subset of simple features forms the <a href="http://geojson.org/">GeoJSON</a> standard.</p>
<p>If you work with PostGis or GeoJSON you may have come across the <a href="https://en.wikipedia.org/wiki/Well-known_text">WKT (well-known text)</a> format, for example like these:</p>
<pre><code>POINT (30 10)
LINESTRING (30 10, 10 30, 40 40)
POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))</code></pre>
<p><code>sf</code> implements this standard natively in R. Data are structured and conceptualized very differently from the <code>sp</code> approach.</p>
<p>In <code>sf</code> spatial objects are stored as a simple data frame with a special column that contains the information for the geographic coordinates. That special column is a list with the same length as the number of rows in the data frame. Each of the individual list elements then can be of any length needed to hold the coordinates that correspond to an individual feature.</p>
<p>To create a spatial object manually the basic steps would be:</p>
<div id="i.-create-geometric-objects-topology-1" class="section level3">
<h3>I. Create geometric objects (topology)</h3>
<p>Geometric objects (simple features) can be created from a numeric vector, matrix or a list with the coordinates. They are called <code>sfg</code> objects for Simple Feature Geometry.</p>
<p>See here for an example of how a LINESTRING <code>sfg</code> object is created:</p>
<pre class="r"><code>lnstr_sfg &lt;- st_linestring(matrix(runif(6), ncol=2)) 
class(lnstr_sfg)</code></pre>
<pre><code>## [1] &quot;XY&quot;         &quot;LINESTRING&quot; &quot;sfg&quot;</code></pre>
</div>
<div id="ii.-combine-all-individual-single-feature-objects-for-the-special-column." class="section level3">
<h3>II. Combine all individual single feature objects for the special column.</h3>
<p>In order to work our way towards a data frame for all features we create what is called an <code>sfc</code> object with all individual features, which stands for Simple Feature Collection. The <code>sfc</code> object also holds the bounding box and the projection information.</p>
<p>See here for an example of how a <code>sfc</code> object is created:</p>
<pre class="r"><code>(lnstr_sfc &lt;- st_sfc(lnstr_sfg)) # just one feature here</code></pre>
<pre><code>## Geometry set for 1 feature 
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: 0.06690928 ymin: 0.397197 xmax: 0.68381 ymax: 0.891195
## epsg (SRID):    NA
## proj4string:    NA</code></pre>
<pre><code>## LINESTRING (0.06690928 0.6273856, 0.68381 0.891...</code></pre>
<pre class="r"><code>class(lnstr_sfc) </code></pre>
<pre><code>## [1] &quot;sfc_LINESTRING&quot; &quot;sfc&quot;</code></pre>
</div>
<div id="iii.-add-attributes." class="section level3">
<h3>III. Add attributes.</h3>
<p>We now combine the dataframe with the attributes and the simple feature collection. See here how its done.</p>
<pre class="r"><code>(lnstr_sf &lt;- st_sf(dfr , lnstr_sfc))</code></pre>
<pre><code>## Simple feature collection with 1 feature and 3 fields
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: 0.06690928 ymin: 0.397197 xmax: 0.68381 ymax: 0.891195
## epsg (SRID):    NA
## proj4string:    NA
##   id  use cars_per_hour                      lnstr_sfc
## 1  a road            10 LINESTRING (0.06690928 0.62...</code></pre>
<pre class="r"><code>class(lnstr_sf)</code></pre>
<pre><code>## [1] &quot;sf&quot;         &quot;data.frame&quot;</code></pre>
<p>There are many methods available in the <code>sf</code> package, to find out use <code>methods(class=&quot;sp&quot;)</code></p>
<p>Here are some of the other highlights of <code>sf</code> you might be interested in:</p>
<ul>
<li>provides <strong>fast</strong> I/O, particularly relevant for large files</li>
<li>directly reads from and writes to spatial <strong>databases</strong> such as PostGIS</li>
<li>stay tuned for a new <code>ggplot</code> release that will be able to read and plot the <code>sf</code> format without the need of conversion to a data frame, like the <code>sp</code> format</li>
</ul>
<p>Note that <code>sp</code> and <code>sf</code> are not the only way spatial objects are conceptualized in R. Other spatial packages may use their own class definitions for spatial data (for example <code>spatstat</code>). Usually you can find functions that convert <code>sp</code> and increasingly <code>sf</code> objects to and from these formats.</p>
</div>
</div>
<div id="sf-objects-with-simple-features" class="section level2">
<h2>sf: objects with simple features</h2>
<p>As we usually do not work with geometries of single simple features, but with datasets consisting of sets of features with attributes, the two are put together in <code>sf</code> (simple feature) objects. The following command reads the <code>nc</code> dataset from a file that is contained in the <code>sf</code> package:</p>
<pre class="r"><code>file=system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;)
file</code></pre>
<pre><code>## [1] &quot;/Library/Frameworks/R.framework/Versions/3.4/Resources/library/sf/shape/nc.shp&quot;</code></pre>
<pre class="r"><code>nc &lt;- st_read(file)</code></pre>
<pre><code>## Reading layer `nc&#39; from data source `/Library/Frameworks/R.framework/Versions/3.4/Resources/library/sf/shape/nc.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 100 features and 14 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965
## epsg (SRID):    4267
## proj4string:    +proj=longlat +datum=NAD27 +no_defs</code></pre>
<p>(Note that you will rarely use <code>system.file</code> but instead give a <code>filename</code> directly, and that shapefiles consist of more than one file, all with identical basename, which reside in the same directory.)</p>
<p>The short report printed gives the file name, the driver (ESRI Shapefile), mentions that there are 100 features (records, represented as rows) and 14 fields (attributes, represented as columns). This object is of class</p>
<pre class="r"><code>class(nc)</code></pre>
<pre><code>## [1] &quot;sf&quot;         &quot;data.frame&quot;</code></pre>
<p>meaning it extends (and “is” a) <code>data.frame</code>, but with a single list-column with geometries, which is held in the column with name</p>
<pre class="r"><code>attr(nc, &quot;sf_column&quot;)</code></pre>
<pre><code>## [1] &quot;geometry&quot;</code></pre>
<p>If we print the first three features, we see their attribute values and an abridged version of the geometry</p>
<pre class="r"><code>print(nc[9:15], n = 3)</code></pre>
<p>which would give the following output:</p>
<p><img src="04_Spatial_with_sf/sf_xfig.png" /></p>
<p>In the output we see:</p>
<ul>
<li>in green a simple feature: a single record, or <code>data.frame</code> row, consisting of attributes and geometry</li>
<li>in blue a single simple feature geometry (an object of class <code>sfg</code>)</li>
<li>in red a simple feature list-column (an object of class <code>sfc</code>, which is a column in the <code>data.frame</code>)</li>
<li>that although geometries are native R objects, they are printed as <a href="#wkb">well-known text</a></li>
</ul>
<p>Methods for <code>sf</code> objects are</p>
<pre class="r"><code>methods(class = &quot;sf&quot;)</code></pre>
<pre><code>##  [1] [                     [[&lt;-                  $&lt;-                  
##  [4] aggregate             anti_join             arrange              
##  [7] as.data.frame         cbind                 coerce               
## [10] dbDataType            dbWriteTable          distinct             
## [13] extent                extract               filter               
## [16] full_join             gather                group_by             
## [19] identify              initialize            inner_join           
## [22] left_join             mask                  merge                
## [25] mutate                nest                  plot                 
## [28] print                 rasterize             rbind                
## [31] rename                right_join            sample_frac          
## [34] sample_n              select                semi_join            
## [37] separate              show                  slice                
## [40] slotsFromS3           spread                st_agr               
## [43] st_agr&lt;-              st_as_sf              st_bbox              
## [46] st_boundary           st_buffer             st_cast              
## [49] st_centroid           st_collection_extract st_convex_hull       
## [52] st_coordinates        st_crs                st_crs&lt;-             
## [55] st_difference         st_geometry           st_geometry&lt;-        
## [58] st_intersection       st_is                 st_line_merge        
## [61] st_node               st_point_on_surface   st_polygonize        
## [64] st_precision          st_segmentize         st_set_precision     
## [67] st_simplify           st_snap               st_sym_difference    
## [70] st_transform          st_triangulate        st_union             
## [73] st_voronoi            st_wrap_dateline      st_write             
## [76] st_zm                 summarise             transmute            
## [79] ungroup               unite                 unnest               
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>It is also possible to create <code>data.frame</code> objects with geometry list-columns that are not of class <code>sf</code>, e.g. by</p>
<pre class="r"><code>nc.no_sf &lt;- as.data.frame(nc)
class(nc.no_sf)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>However, such objects:</p>
<ul>
<li>no longer register which column is the geometry list-column</li>
<li>no longer have a plot method, and</li>
<li>lack all of the other dedicated methods listed above for class <code>sf</code></li>
</ul>
</div>
<div id="sfc-simple-feature-geometry-list-column" class="section level2">
<h2>sfc: simple feature geometry list-column</h2>
<p>The column in the <code>sf</code> data.frame that contains the geometries is a list, of class <code>sfc</code>. We can retrieve the geometry list-column in this case by <code>nc$geom</code> or <code>nc[[15]]</code>, but the more general way uses <code>st_geometry</code>:</p>
<pre class="r"><code>nc_geom &lt;- st_geometry(nc)</code></pre>
<p>Geometries are printed in abbreviated form, but we can can view a complete geometry by selecting it, e.g. the first one by</p>
<pre class="r"><code>nc_geom[[1]]</code></pre>
<pre><code>## MULTIPOLYGON (((-81.47276 36.23436, -81.54084 36.27251, -81.56198 36.27359, -81.63306 36.34069, -81.74107 36.39178, -81.69828 36.47178, -81.7028 36.51934, -81.67 36.58965, -81.3453 36.57286, -81.34754 36.53791, -81.32478 36.51368, -81.31332 36.4807, -81.26624 36.43721, -81.26284 36.40504, -81.24069 36.37942, -81.23989 36.36536, -81.26424 36.35241, -81.32899 36.3635, -81.36137 36.35316, -81.36569 36.33905, -81.35413 36.29972, -81.36745 36.2787, -81.40639 36.28505, -81.41233 36.26729, -81.43104 36.26072, -81.45289 36.23959, -81.47276 36.23436)))</code></pre>
<p>The way this is printed is called <em>well-known text</em>, and is part of the standards. The word <code>MULTIPOLYGON</code> is followed by three parenthesis, because it can consist of multiple polygons, in the form of <code>MULTIPOLYGON(POL1,POL2)</code>, where <code>POL1</code> might consist of an exterior ring and zero or more interior rings, as of <code>(EXT1,HOLE1,HOLE2)</code>. Sets of coordinates are held together with parenthesis, so we get <code>((crds_ext)(crds_hole1)(crds_hole2))</code> where <code>crds_</code> is a comma-separated set of coordinates of a ring. This leads to the case above, where <code>MULTIPOLYGON(((crds_ext)))</code> refers to the exterior ring (1), without holes (2), of the first polygon (3) - hence three parentheses.</p>
<p>We can see there is a single polygon with no rings:</p>
<pre class="r"><code>plot(nc[1])
plot(nc[1,1], col = &#39;grey&#39;, add = TRUE)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-18-1.png" /><!-- --></p>
<p>but some of the polygons in this dataset have multiple exterior rings; they can be identified by</p>
<pre class="r"><code>w &lt;- which(sapply(nc_geom, length) &gt; 1)
plot(nc[w,1], col = 2:7)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-19-1.png" /><!-- --></p>
<p>Following the <code>MULTIPOLYGON</code> datastructure, in R we have a list of lists of lists of matrices. For instance, we get the coordinate pairs of the second exterior ring (first ring is always exterior) for the geometry of feature 4 by</p>
<pre class="r"><code>nc_geom[[4]][[2]][[1]]</code></pre>
<pre><code>##           [,1]     [,2]
## [1,] -76.02717 36.55672
## [2,] -75.99866 36.55665
## [3,] -75.91192 36.54253
## [4,] -75.92480 36.47398
## [5,] -75.97728 36.47802
## [6,] -75.97629 36.51793
## [7,] -76.02717 36.55672</code></pre>
<p>Geometry columns have their own class,</p>
<pre class="r"><code>class(nc_geom)</code></pre>
<pre><code>## [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot;</code></pre>
<p>Methods for geometry list-columns include</p>
<pre class="r"><code>methods(class = &#39;sfc&#39;)</code></pre>
<pre><code>##  [1] [                     [&lt;-                   as.data.frame        
##  [4] c                     coerce                format               
##  [7] fortify               identify              initialize           
## [10] obj_sum               Ops                   print                
## [13] rep                   scale_type            show                 
## [16] slotsFromS3           st_as_binary          st_as_text           
## [19] st_bbox               st_boundary           st_buffer            
## [22] st_cast               st_centroid           st_collection_extract
## [25] st_convex_hull        st_coordinates        st_crs               
## [28] st_crs&lt;-              st_difference         st_geometry          
## [31] st_intersection       st_is                 st_line_merge        
## [34] st_node               st_point_on_surface   st_polygonize        
## [37] st_precision          st_segmentize         st_set_precision     
## [40] st_simplify           st_snap               st_sym_difference    
## [43] st_transform          st_triangulate        st_union             
## [46] st_voronoi            st_wrap_dateline      st_write             
## [49] st_zm                 str                   summary              
## [52] type_sum             
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>Coordinate reference systems (<code>st_crs</code> and <code>st_transform</code>) are discussed in the section on <a href="#crs">coordinate reference systems</a>. <code>st_as_wkb</code> and <code>st_as_text</code> convert geometry list-columns into well-known-binary or well-known-text, explained <a href="#wkb">below</a>. <code>st_bbox</code> retrieves the coordinate bounding box.</p>
<p>Attributes include</p>
<pre class="r"><code>attributes(nc_geom)</code></pre>
<pre><code>## $n_empty
## [1] 0
## 
## $crs
## Coordinate Reference System:
##   EPSG: 4267 
##   proj4string: &quot;+proj=longlat +datum=NAD27 +no_defs&quot;
## 
## $class
## [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot;             
## 
## $precision
## [1] 0
## 
## $bbox
##      xmin      ymin      xmax      ymax 
## -84.32385  33.88199 -75.45698  36.58965</code></pre>
</div>
<div id="mixed-geometry-types" class="section level2">
<h2>Mixed geometry types</h2>
<p>The class of <code>nc_geom</code> is <code>c(&quot;sfc_MULTIPOLYGON&quot;, &quot;sfc&quot;)</code>: <code>sfc</code> is shared with all geometry types, and <code>sfc_TYPE</code> with <code>TYPE</code> indicating the type of the particular geometry at hand.</p>
<p>There are two “special” types: <code>GEOMETRYCOLLECTION</code>, and <code>GEOMETRY</code>. <code>GEOMETRYCOLLECTION</code> indicates that each of the geometries may contain a mix of geometry types, as in</p>
<pre class="r"><code>mix &lt;- st_sfc(st_geometrycollection(list(st_point(1:2))),
    st_geometrycollection(list(st_linestring(matrix(1:4,2)))))
class(mix)</code></pre>
<pre><code>## [1] &quot;sfc_GEOMETRYCOLLECTION&quot; &quot;sfc&quot;</code></pre>
<p>Still, the geometries are here of a single type.</p>
<p>The second <code>GEOMETRY</code>, indicates that the geometries in the geometry list-column are of varying type:</p>
<pre class="r"><code>mix &lt;- st_sfc(st_point(1:2), st_linestring(matrix(1:4,2)))
class(mix)</code></pre>
<pre><code>## [1] &quot;sfc_GEOMETRY&quot; &quot;sfc&quot;</code></pre>
<p>These two are fundamentally different: <code>GEOMETRY</code> is a superclass without instances, <code>GEOMETRYCOLLECTION</code> is a geometry instance. <code>GEOMETRY</code> list-columns occur when we read in a data source with a mix of geometry types. <code>GEOMETRYCOLLECTION</code> <em>is</em> a single feature’s geometry: the intersection of two feature polygons may consist of points, lines and polygons, see the example <a href="#geometrycollection">below</a>.</p>
</div>
<div id="sfg-simple-feature-geometry" class="section level2">
<h2>sfg: simple feature geometry</h2>
<p>Simple feature geometry (<code>sfg</code>) objects carry the geometry for a single feature, e.g. a point, linestring or polygon.</p>
<p>Simple feature geometries are implemented as R native data, using the following rules</p>
<ol style="list-style-type: decimal">
<li>a single POINT is a numeric vector</li>
<li>a set of points, e.g. in a LINESTRING or ring of a POLYGON is a <code>matrix</code>, each row containing a point</li>
<li>any other set is a <code>list</code></li>
</ol>
<p>Creator functions are rarely used in practice, since we typically bulk read and write spatial data. They are useful for illustration:</p>
<pre class="r"><code>(x &lt;- st_point(c(1,2)))</code></pre>
<pre><code>## POINT (1 2)</code></pre>
<pre class="r"><code>str(x)</code></pre>
<pre><code>## Classes &#39;XY&#39;, &#39;POINT&#39;, &#39;sfg&#39;  num [1:2] 1 2</code></pre>
<pre class="r"><code>(x &lt;- st_point(c(1,2,3)))</code></pre>
<pre><code>## POINT Z (1 2 3)</code></pre>
<pre class="r"><code>str(x)</code></pre>
<pre><code>## Classes &#39;XYZ&#39;, &#39;POINT&#39;, &#39;sfg&#39;  num [1:3] 1 2 3</code></pre>
<pre class="r"><code>(x &lt;- st_point(c(1,2,3), &quot;XYM&quot;))</code></pre>
<pre><code>## POINT M (1 2 3)</code></pre>
<pre class="r"><code>str(x)</code></pre>
<pre><code>## Classes &#39;XYM&#39;, &#39;POINT&#39;, &#39;sfg&#39;  num [1:3] 1 2 3</code></pre>
<pre class="r"><code>(x &lt;- st_point(c(1,2,3,4)))</code></pre>
<pre><code>## POINT ZM (1 2 3 4)</code></pre>
<pre class="r"><code>str(x)</code></pre>
<pre><code>## Classes &#39;XYZM&#39;, &#39;POINT&#39;, &#39;sfg&#39;  num [1:4] 1 2 3 4</code></pre>
<pre class="r"><code>st_zm(x, drop = TRUE, what = &quot;ZM&quot;)</code></pre>
<pre><code>## POINT (1 2)</code></pre>
<p>This means that we can represent 2-, 3- or 4-dimensional coordinates. All geometry objects inherit from <code>sfg</code> (simple feature geometry), but also have a type (e.g. <code>POINT</code>), and a dimension (e.g. <code>XYM</code>) class name. A figure illustrates six of the seven most common types.</p>
<p>With the exception of the <code>POINT</code> which has a single point as geometry, the remaining six common single simple feature geometry types that correspond to single features (single records, or rows in a <code>data.frame</code>) are created like this</p>
<pre class="r"><code>p &lt;- rbind(c(3.2,4), c(3,4.6), c(3.8,4.4), c(3.5,3.8), c(3.4,3.6), c(3.9,4.5))
(mp &lt;- st_multipoint(p))</code></pre>
<pre><code>## MULTIPOINT (3.2 4, 3 4.6, 3.8 4.4, 3.5 3.8, 3.4 3.6, 3.9 4.5)</code></pre>
<pre class="r"><code>s1 &lt;- rbind(c(0,3),c(0,4),c(1,5),c(2,5))
(ls &lt;- st_linestring(s1))</code></pre>
<pre><code>## LINESTRING (0 3, 0 4, 1 5, 2 5)</code></pre>
<pre class="r"><code>s2 &lt;- rbind(c(0.2,3), c(0.2,4), c(1,4.8), c(2,4.8))
s3 &lt;- rbind(c(0,4.4), c(0.6,5))
(mls &lt;- st_multilinestring(list(s1,s2,s3)))</code></pre>
<pre><code>## MULTILINESTRING ((0 3, 0 4, 1 5, 2 5), (0.2 3, 0.2 4, 1 4.8, 2 4.8), (0 4.4, 0.6 5))</code></pre>
<pre class="r"><code>p1 &lt;- rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0))
p2 &lt;- rbind(c(1,1), c(1,2), c(2,2), c(1,1))
pol &lt;-st_polygon(list(p1,p2))
p3 &lt;- rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0))
p4 &lt;- rbind(c(3.3,0.3), c(3.8,0.3), c(3.8,0.8), c(3.3,0.8), c(3.3,0.3))[5:1,]
p5 &lt;- rbind(c(3,3), c(4,2), c(4,3), c(3,3))
(mpol &lt;- st_multipolygon(list(list(p1,p2), list(p3,p4), list(p5))))</code></pre>
<pre><code>## MULTIPOLYGON (((0 0, 1 0, 3 2, 2 4, 1 4, 0 0), (1 1, 1 2, 2 2, 1 1)), ((3 0, 4 0, 4 1, 3 1, 3 0), (3.3 0.3, 3.3 0.8, 3.8 0.8, 3.8 0.3, 3.3 0.3)), ((3 3, 4 2, 4 3, 3 3)))</code></pre>
<pre class="r"><code>(gc &lt;- st_geometrycollection(list(mp, mpol, ls)))</code></pre>
<pre><code>## GEOMETRYCOLLECTION (MULTIPOINT (3.2 4, 3 4.6, 3.8 4.4, 3.5 3.8, 3.4 3.6, 3.9 4.5), MULTIPOLYGON (((0 0, 1 0, 3 2, 2 4, 1 4, 0 0), (1 1, 1 2, 2 2, 1 1)), ((3 0, 4 0, 4 1, 3 1, 3 0), (3.3 0.3, 3.3 0.8, 3.8 0.8, 3.8 0.3, 3.3 0.3)), ((3 3, 4 2, 4 3, 3 3))), LINESTRING (0 3, 0 4, 1 5, 2 5))</code></pre>
<p>The objects created are shown here:</p>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-28-1.png" /><!-- --></p>
<p>Geometries can also be empty, as in</p>
<pre class="r"><code>x &lt;- st_geometrycollection()
length(x)</code></pre>
<pre><code>## [1] 0</code></pre>
</div>
<div id="wkb" class="section level2">
<h2>Well-known text, well-known binary, precision</h2>
<div id="wkt-and-wkb" class="section level3">
<h3>WKT and WKB</h3>
<p>Well-known text (WKT) and well-known binary (WKB) are two encodings for simple feature geometries. Well-known text, e.g. seen in</p>
<pre class="r"><code>x &lt;- st_linestring(matrix(10:1,5))
st_as_text(x)</code></pre>
<pre><code>## [1] &quot;LINESTRING (10 5, 9 4, 8 3, 7 2, 6 1)&quot;</code></pre>
<p>(but without the leading <code>## [1]</code> and quotes), is human-readable. Coordinates are usually floating point numbers, and moving large amounts of information as text is slow and imprecise. For that reason, we use well-known binary (WKB) encoding</p>
<pre class="r"><code>st_as_binary(x)</code></pre>
<pre><code>##  [1] 01 02 00 00 00 05 00 00 00 00 00 00 00 00 00 24 40 00 00 00 00 00 00
## [24] 14 40 00 00 00 00 00 00 22 40 00 00 00 00 00 00 10 40 00 00 00 00 00
## [47] 00 20 40 00 00 00 00 00 00 08 40 00 00 00 00 00 00 1c 40 00 00 00 00
## [70] 00 00 00 40 00 00 00 00 00 00 18 40 00 00 00 00 00 00 f0 3f</code></pre>
<p>WKT and WKB can both be transformed back into R native objects by</p>
<pre class="r"><code>st_as_sfc(&quot;LINESTRING(10 5, 9 4, 8 3, 7 2, 6 1)&quot;)[[1]]</code></pre>
<pre><code>## LINESTRING (10 5, 9 4, 8 3, 7 2, 6 1)</code></pre>
<pre class="r"><code>st_as_sfc(structure(list(st_as_binary(x)), class = &quot;WKB&quot;))[[1]]</code></pre>
<pre><code>## LINESTRING (10 5, 9 4, 8 3, 7 2, 6 1)</code></pre>
<p>GDAL, GEOS, spatial databases and GIS read and write WKB which is fast and precise. Conversion between R native objects and WKB is done by package <code>sf</code> in compiled (C++/Rcpp) code, making this a reusable and fast route for I/O of simple feature geometries in R.</p>
</div>
</div>
<div id="reading-and-writing" class="section level2">
<h2>Reading and writing</h2>
<p>As we’ve seen above, reading spatial data from an external file can be done by</p>
<pre class="r"><code>filename &lt;- system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;)
nc &lt;- st_read(filename)</code></pre>
<pre><code>## Reading layer `nc&#39; from data source `/Library/Frameworks/R.framework/Versions/3.4/Resources/library/sf/shape/nc.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 100 features and 14 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965
## epsg (SRID):    4267
## proj4string:    +proj=longlat +datum=NAD27 +no_defs</code></pre>
<p>we can suppress the output by adding argument <code>quiet=TRUE</code> or by using the otherwise nearly identical but more quiet</p>
<pre class="r"><code>nc &lt;- read_sf(filename)</code></pre>
<p>Writing takes place in the same fashion, using <code>st_write</code>:</p>
<pre class="r"><code>st_write(nc, &quot;nc.shp&quot;)</code></pre>
<pre><code>## Writing layer `nc&#39; to data source `nc.shp&#39; using driver `ESRI Shapefile&#39;
## features:       100
## fields:         14
## geometry type:  Multi Polygon</code></pre>
<p>If we repeat this, we get an error message that the file already exists, and we can overwrite by</p>
<pre class="r"><code>st_write(nc, &quot;nc.shp&quot;, delete_layer = TRUE)</code></pre>
<pre><code>## Deleting layer `nc&#39; using driver `ESRI Shapefile&#39;
## Writing layer `nc&#39; to data source `/Users/adamw/Documents/repos/SpatialDataScience/nc.shp&#39; using driver `ESRI Shapefile&#39;
## features:       100
## fields:         14
## geometry type:  Multi Polygon</code></pre>
<p>or its quiet alternative that does this by default,</p>
<pre class="r"><code>write_sf(nc, &quot;nc.shp&quot;) # silently overwrites</code></pre>
<div id="driver-specific-options" class="section level3">
<h3>Driver-specific options</h3>
<p>The <code>dsn</code> and <code>layer</code> arguments to <code>st_read</code> and <code>st_write</code> denote a data source name and optionally a layer name. Their exact interpretation as well as the options they support vary per driver, the <a href="http://www.gdal.org/ogr_formats.html">GDAL driver documentation</a> is best consulted for this. For instance, a PostGIS table in database <code>postgis</code> might be read by</p>
<pre class="r"><code>meuse &lt;- st_read(&quot;PG:dbname=postgis&quot;, &quot;meuse&quot;)</code></pre>
<p>where the <code>PG:</code> string indicates this concerns the PostGIS driver, followed by database name, and possibly port and user credentials. When the <code>layer</code> and <code>driver</code> arguments are not specified, <code>st_read</code> tries to guess them from the datasource, or else simply reads the first layer, giving a warning in case there are more.</p>
<p><code>st_read</code> typically reads the coordinate reference system as <code>proj4string</code>, but not the EPSG (SRID). GDAL cannot retrieve SRID (EPSG code) from <code>proj4string</code> strings, and, when needed, it has to be set by the user. See also the section on <a href="crs" class="uri">crs</a>.</p>
<p><code>st_drivers()</code> returns a <code>data.frame</code> listing available drivers, and their metadata: names, whether a driver can write, and whether it is a raster and/or vector driver. All drivers can read. Reading of some common data formats is illustrated below:</p>
<p><code>st_layers(dsn)</code> lists the layers present in data source <code>dsn</code>, and gives the number of fields, features and geometry type for each layer:</p>
<pre class="r"><code>st_layers(system.file(&quot;osm/overpass.osm&quot;, package=&quot;sf&quot;))</code></pre>
<pre><code>## Driver: OSM 
## Available layers:
##         layer_name       geometry_type features fields
## 1           points               Point       NA     10
## 2            lines         Line String       NA      9
## 3 multilinestrings   Multi Line String       NA      4
## 4    multipolygons       Multi Polygon       NA     25
## 5  other_relations Geometry Collection       NA      4</code></pre>
<p>we see that in this case, the number of features is <code>NA</code> because for this xml file the whole file needs to be read, which may be costly for large files. We can force counting by</p>
<pre class="r"><code>Sys.setenv(OSM_USE_CUSTOM_INDEXING=&quot;NO&quot;)
st_layers(system.file(&quot;osm/overpass.osm&quot;, package=&quot;sf&quot;), do_count = TRUE)</code></pre>
<pre><code>## Driver: OSM 
## Available layers:
##         layer_name       geometry_type features fields
## 1           points               Point        1     10
## 2            lines         Line String        0      9
## 3 multilinestrings   Multi Line String        0      4
## 4    multipolygons       Multi Polygon        0     25
## 5  other_relations Geometry Collection        0      4</code></pre>
<p>Another example of reading kml and kmz files is:</p>
<pre class="r"><code># Download .shp data
u_shp &lt;- &quot;http://coagisweb.cabq.gov/datadownload/biketrails.zip&quot;
download.file(u_shp, &quot;biketrails.zip&quot;)
unzip(&quot;biketrails.zip&quot;)
u_kmz &lt;- &quot;http://coagisweb.cabq.gov/datadownload/BikePaths.kmz&quot;
download.file(u_kmz, &quot;BikePaths.kmz&quot;)
# Read file formats
biketrails_shp &lt;- st_read(&quot;biketrails.shp&quot;)
if(Sys.info()[1] == &quot;Linux&quot;) # may not work if not Linux
  biketrails_kmz &lt;- st_read(&quot;BikePaths.kmz&quot;)
u_kml = &quot;http://www.northeastraces.com/oxonraces.com/nearme/safe/6.kml&quot;
download.file(u_kml, &quot;bikeraces.kml&quot;)
bikraces &lt;- st_read(&quot;bikeraces.kml&quot;)</code></pre>
</div>
<div id="crud" class="section level3">
<h3>Create, read, update and delete</h3>
<p>GDAL provides the <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">crud</a> (create, read, update, delete) functions to persistent storage. <code>st_read</code> (or <code>read_sf</code>) are used for reading. <code>st_write</code> (or <code>write_sf</code>) creates, and has the following arguments to control update and delete:</p>
<ul>
<li><code>update=TRUE</code> causes an existing data source to be updated, if it exists; this options is by default <code>TRUE</code> for all database drivers, where the database is updated by adding a table.</li>
<li><code>delete_layer=TRUE</code> causes <code>st_write</code> try to open the the data source and delete the layer; no errors are given if the data source is not present, or the layer does not exist in the data source.</li>
<li><code>delete_dsn=TRUE</code> causes <code>st_write</code> to delete the data source when present, before writing the layer in a newly created data source. No error is given when the data source does not exist. This option should be handled with care, as it may wipe complete directories or databases.</li>
</ul>
</div>
<div id="directly-reading-and-writing-to-spatial-databases" class="section level3">
<h3>Directly reading and writing to spatial databases</h3>
<p>Two further functions, <code>st_read_db</code> and <code>st_write_db</code> attempt to read and write from spatial databases, directly reading WKB or WKT without using GDAL. The advantage over <code>st_read</code> may be that instead of a complete table, the result of a (spatial) query may be fetched, limiting the amount of data that is read into R, and potentially benefiting from the spatial index of the database. Although intended to use the DBI interface, current use and testing of these functions are limited to PostGIS.</p>
</div>
</div>
<div id="crs" class="section level2">
<h2>Coordinate reference systems and transformations</h2>
<p>Coordinate reference systems (CRS) are like measurement units for coordinates: they specify which location on Earth a particular coordinate pair refers to. We saw above that <code>sfc</code> objects (geometry list-columns) have two attributes to store a CRS: <code>epsg</code> and <code>proj4string</code>. This implies that all geometries in a geometry list-column must have the same CRS. Both may be <code>NA</code>, e.g. in case the CRS is unknown, or when we work with local coordinate systems (e.g. inside a building, a body, or an abstract space).</p>
<p><code>proj4string</code> is a generic, string-based description of a CRS, understood by the <a href="http://proj4.org/">PROJ.4</a> library. It defines projection types and (often) defines parameter values for particular projections, and hence can cover an infinite amount of different projections. This library (also used by GDAL) provides functions to convert or transform between different CRS. <code>epsg</code> is the integer ID for a particular, known CRS that can be resolved into a <code>proj4string</code>. There is no (known, simple and general) way to resolve <code>proj4string</code> values into <code>epsg</code> IDs.</p>
<p>The importance of having <code>epsg</code> values stored with data besides <code>proj4string</code> values is that the <code>epsg</code> refers to particular, well-known CRS, whose parameters may change (improve) over time; fixing only the <code>proj4string</code> may remove the possibility to benefit from such improvements, and limit the provenance of datasets.</p>
<p>Coordinate reference system transformations can be carried out using <code>st_transform</code>, e.g. converting longitudes/latitudes in NAD27 to web mercator (EPSG:3857) can be done by</p>
<pre class="r"><code>nc.web_mercator &lt;- st_transform(nc, 3857)
st_geometry(nc.web_mercator)[[4]][[2]][[1]][1:3,]</code></pre>
<pre><code>##          [,1]    [,2]
## [1,] -8463306 4377498
## [2,] -8460133 4377489
## [3,] -8450476 4375532</code></pre>
</div>
<div id="conversion-including-to-and-from-sp" class="section level2">
<h2>Conversion, including to and from sp</h2>
<p><code>sf</code> objects and objects deriving from <code>Spatial</code> (package <code>sp</code>) can be coerced both ways:</p>
<pre class="r"><code># anticipate that sp::CRS will expand proj4strings:
p4s &lt;- &quot;+proj=longlat +datum=NAD27 +no_defs +ellps=clrk66 +nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat&quot;
st_crs(nc) &lt;- p4s</code></pre>
<pre><code>## Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform
## for that</code></pre>
<pre class="r"><code># anticipate geometry column name changes:
names(nc)[15] = &quot;geometry&quot;
attr(nc, &quot;sf_column&quot;) = &quot;geometry&quot;
nc.sp &lt;- as(nc, &quot;Spatial&quot;)
class(nc.sp)</code></pre>
<pre><code>## [1] &quot;SpatialPolygonsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<pre class="r"><code>nc2 &lt;- st_as_sf(nc.sp)
#all.equal(nc, nc2)</code></pre>
<p>As the <code>Spatial*</code> objects only support <code>MULTILINESTRING</code> and <code>MULTIPOLYGON</code>, <code>LINESTRING</code> and <code>POLYGON</code> geometries are automatically coerced into their <code>MULTI</code> form. When converting <code>Spatial*</code> into <code>sf</code>, if all geometries consist of a single <code>POLYGON</code> (possibly with holes), a <code>POLYGON</code> and otherwise all geometries are returned as <code>MULTIPOLYGON</code>: a mix of <code>POLYGON</code> and <code>MULTIPOLYGON</code> (such as common in shapefiles) is not created. Argument <code>forceMulti=TRUE</code> will override this, and create <code>MULTIPOLYGON</code>s in all cases. For <code>LINES</code> the situation is identical.</p>
</div>
<div id="geometrycollection" class="section level2">
<h2>Geometrical operations</h2>
<p>The standard for simple feature access defines a number of geometrical operations.</p>
<p><code>st_is_valid</code> and <code>st_is_simple</code> return a boolean indicating whether a geometry is valid or simple.</p>
<pre class="r"><code>st_is_valid(nc[1:2,])</code></pre>
<pre><code>## [1] TRUE TRUE</code></pre>
<p><code>st_distance</code> returns a dense numeric matrix with distances between geometries. <code>st_relate</code> returns a character matrix with the <a href="https://en.wikipedia.org/wiki/DE-9IM#Illustration">DE9-IM</a> values for each pair of geometries:</p>
<pre class="r"><code>x = st_transform(nc, 32119)
st_distance(x[c(1,4,22),], x[c(1, 33,55,56),])</code></pre>
<pre><code>## Units: m
##           [,1]     [,2]      [,3]     [,4]
## [1,]      0.00 312176.2 128338.51 475608.8
## [2,] 440548.35 114938.1 590417.79      0.0
## [3,]  18943.74 352708.6  78754.75 517511.6</code></pre>
<pre class="r"><code>st_relate(nc[1:5,], nc[1:4,])</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_relate assumes that they are planar</code></pre>
<pre><code>##      [,1]        [,2]        [,3]        [,4]       
## [1,] &quot;2FFF1FFF2&quot; &quot;FF2F11212&quot; &quot;FF2FF1212&quot; &quot;FF2FF1212&quot;
## [2,] &quot;FF2F11212&quot; &quot;2FFF1FFF2&quot; &quot;FF2F11212&quot; &quot;FF2FF1212&quot;
## [3,] &quot;FF2FF1212&quot; &quot;FF2F11212&quot; &quot;2FFF1FFF2&quot; &quot;FF2FF1212&quot;
## [4,] &quot;FF2FF1212&quot; &quot;FF2FF1212&quot; &quot;FF2FF1212&quot; &quot;2FFF1FFF2&quot;
## [5,] &quot;FF2FF1212&quot; &quot;FF2FF1212&quot; &quot;FF2FF1212&quot; &quot;FF2FF1212&quot;</code></pre>
<p>The commands <code>st_intersects</code>, <code>st_disjoint</code>, <code>st_touches</code>, <code>st_crosses</code>, <code>st_within</code>, <code>st_contains</code>, <code>st_overlaps</code>, <code>st_equals</code>, <code>st_covers</code>, <code>st_covered_by</code>, <code>st_equals_exact</code> and <code>st_is_within_distance</code> return a sparse matrix with matching (TRUE) indexes, or a full logical matrix:</p>
<pre class="r"><code>st_intersects(nc[1:5,], nc[1:4,])</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre><code>## Sparse geometry binary predicate list of length 5, where the predicate was `intersects&#39;
##  1: 1, 2
##  2: 1, 2, 3
##  3: 2, 3
##  4: 4
##  5: (empty)</code></pre>
<pre class="r"><code>st_intersects(nc[1:5,], nc[1:4,], sparse = FALSE)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,]  TRUE  TRUE FALSE FALSE
## [2,]  TRUE  TRUE  TRUE FALSE
## [3,] FALSE  TRUE  TRUE FALSE
## [4,] FALSE FALSE FALSE  TRUE
## [5,] FALSE FALSE FALSE FALSE</code></pre>
<p>The commands <code>st_buffer</code>, <code>st_boundary</code>, <code>st_convexhull</code>, <code>st_union_cascaded</code>, <code>st_simplify</code>, <code>st_triangulate</code>, <code>st_polygonize</code>, <code>st_centroid</code>, <code>st_segmentize</code>, and <code>st_union</code> return new geometries, e.g.:</p>
<pre class="r"><code>sel &lt;- c(1,5,14)
geom = st_geometry(nc.web_mercator[sel,])
buf &lt;- st_buffer(geom, dist = 30000)
plot(buf, border = &#39;red&#39;)
plot(geom, add = TRUE)
plot(st_buffer(geom, -5000), add = TRUE, border = &#39;blue&#39;)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-47-1.png" /><!-- --></p>
<p>Commands <code>st_intersection</code>, <code>st_union</code>, <code>st_difference</code>, <code>st_sym_difference</code> return new geometries that are a function of pairs of geometries:</p>
<pre class="r"><code>par(mar = rep(0,4))
u &lt;- st_union(nc)
plot(u)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-48-1.png" /><!-- --></p>
<p>The following code shows how computing an intersection between two polygons may yield a <code>GEOMETRYCOLLECTION</code> with a point, line and polygon:</p>
<pre class="r"><code>opar &lt;- par(mfrow = c(1, 2))
a &lt;- st_polygon(list(cbind(c(0,0,7.5,7.5,0),c(0,-1,-1,0,0))))
b &lt;- st_polygon(list(cbind(c(0,1,2,3,4,5,6,7,7,0),c(1,0,.5,0,0,0.5,-0.5,-0.5,1,1))))
plot(a, ylim = c(-1,1))
title(&quot;intersecting two polygons:&quot;)
plot(b, add = TRUE, border = &#39;red&#39;)
(i &lt;- st_intersection(a,b))</code></pre>
<pre><code>## GEOMETRYCOLLECTION (POINT (1 0), LINESTRING (4 0, 3 0), POLYGON ((5.5 0, 7 0, 7 -0.5, 6 -0.5, 5.5 0)))</code></pre>
<pre class="r"><code>plot(a, ylim = c(-1,1))
title(&quot;GEOMETRYCOLLECTION&quot;)
plot(b, add = TRUE, border = &#39;red&#39;)
plot(i, add = TRUE, col = &#39;green&#39;, lwd = 2)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-49-1.png" /><!-- --></p>
<pre class="r"><code>par(opar)</code></pre>
</div>
<div id="non-valid-geometries" class="section level2">
<h2>Non-valid geometries</h2>
<p>Invalid geometries are for instance self-intersecting lines (left) or polygons with slivers (middle) or self-intersections (right).</p>
<pre class="r"><code>x1 &lt;- st_linestring(cbind(c(0,1,0,1),c(0,1,1,0)))
x2 &lt;- st_polygon(list(cbind(c(0,1,1,1,0,0),c(0,0,1,0.6,1,0))))
x3 &lt;- st_polygon(list(cbind(c(0,1,0,1,0),c(0,1,1,0,0))))
st_is_simple(st_sfc(x1))</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>st_is_valid(st_sfc(x2,x3))</code></pre>
<pre><code>## [1] FALSE FALSE</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-51-1.png" /><!-- --></p>
</div>
</div>
<div id="units" class="section level1">
<h1>Units</h1>
<p>Where possible geometric operations such as <code>st_distance()</code>, <code>st_length()</code> and <code>st_area()</code> report results with a units attribute appropriate for the CRS:</p>
<pre class="r"><code>a &lt;- st_area(nc[1,])
attributes(a)</code></pre>
<pre><code>## $units
## $numerator
## [1] &quot;m&quot; &quot;m&quot;
## 
## $denominator
## character(0)
## 
## attr(,&quot;class&quot;)
## [1] &quot;symbolic_units&quot;
## 
## $class
## [1] &quot;units&quot;</code></pre>
<p>The <strong>units</strong> package can be used to convert between units:</p>
<pre class="r"><code>units::set_units(a, km^2) # result in square kilometers</code></pre>
<pre><code>## 1137.389 km^2</code></pre>
<pre class="r"><code>units::set_units(a, ha) # result in hectares</code></pre>
<pre><code>## 113738.9 ha</code></pre>
<p>The result can be stripped of their attributes if needs be:</p>
<pre class="r"><code>as.numeric(a)</code></pre>
<pre><code>## [1] 1137388604</code></pre>
</div>
<div id="how-attributes-relate-to-geometries" class="section level1">
<h1>How attributes relate to geometries</h1>
<p>(This will eventually be the topic of a new vignette; now here to explain the last attribute of <code>sf</code> objects)</p>
<p>The standard documents about simple features are very detailed about the geometric aspects of features, but say nearly nothing about attributes, except that their values should be understood in another reference system (their units of measurement, e.g. as implemented in the package <a href="https://CRAN.R-project.org/package=units"><strong>units</strong></a>). But there is more to it. For variables like air temperature, interpolation usually makes sense, for others like human body temperature it doesn’t. The difference is that air temperature is a field, which continues between sensors, where body temperature is an object property that doesn’t extend beyond the body – in spatial statistics bodies would be called a point pattern, their temperature the point marks. For geometries that have a non-zero size (positive length or area), attribute values may refer to the every sub-geometry (every point), or may summarize the geometry. For example, a state’s population density summarizes the whole state, and is not a meaningful estimate of population density for a give point inside the state without the context of the state. On the other hand, land use or geological maps give polygons with constant land use or geology, every point inside the polygon is of that class. Some properties are spatially <a href="https://en.wikipedia.org/wiki/Intensive_and_extensive_properties">extensive</a>, meaning that attributes would summed up when two geometries are merged: population is an example. Other properties are spatially intensive, and should be averaged, with population density the example.</p>
<p>Simple feature objects of class <code>sf</code> have an <em>agr</em> attribute that points to the <em>attribute-geometry-relationship</em>, how attributes relate to their geometry. It can be defined at creation time:</p>
<pre class="r"><code>nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;),
    agr = c(AREA = &quot;aggregate&quot;, PERIMETER = &quot;aggregate&quot;, CNTY_ = &quot;identity&quot;,
        CNTY_ID = &quot;identity&quot;, NAME = &quot;identity&quot;, FIPS = &quot;identity&quot;, FIPSNO = &quot;identity&quot;,
        CRESS_ID = &quot;identity&quot;, BIR74 = &quot;aggregate&quot;, SID74 = &quot;aggregate&quot;, NWBIR74 = &quot;aggregate&quot;,
        BIR79 = &quot;aggregate&quot;, SID79 = &quot;aggregate&quot;, NWBIR79 = &quot;aggregate&quot;))</code></pre>
<pre><code>## Reading layer `nc&#39; from data source `/Library/Frameworks/R.framework/Versions/3.4/Resources/library/sf/shape/nc.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 100 features and 14 fields
## Attribute-geometry relationship: 0 constant, 8 aggregate, 6 identity
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965
## epsg (SRID):    4267
## proj4string:    +proj=longlat +datum=NAD27 +no_defs</code></pre>
<pre class="r"><code>st_agr(nc)</code></pre>
<pre><code>##      AREA PERIMETER     CNTY_   CNTY_ID      NAME      FIPS    FIPSNO 
## aggregate aggregate  identity  identity  identity  identity  identity 
##  CRESS_ID     BIR74     SID74   NWBIR74     BIR79     SID79   NWBIR79 
##  identity aggregate aggregate aggregate aggregate aggregate aggregate 
## Levels: constant aggregate identity</code></pre>
<pre class="r"><code>data(meuse, package = &quot;sp&quot;)
meuse_sf &lt;- st_as_sf(meuse, coords = c(&quot;x&quot;, &quot;y&quot;), crs = 28992, agr = &quot;constant&quot;)
st_agr(meuse_sf)</code></pre>
<pre><code>##  cadmium   copper     lead     zinc     elev     dist       om    ffreq 
## constant constant constant constant constant constant constant constant 
##     soil     lime  landuse   dist.m 
## constant constant constant constant 
## Levels: constant aggregate identity</code></pre>
<p>When not specified, this field is filled with <code>NA</code> values, but if non-<code>NA</code>, it has one of three possibilities</p>
<table>
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>constant</td>
<td>a variable that has a constant value at every location over a spatial extent; examples: soil type, climate zone, land use</td>
</tr>
<tr class="even">
<td>aggregate</td>
<td>values are summary values (aggregates) over the geometry, e.g. population density, dominant land use</td>
</tr>
<tr class="odd">
<td>identity</td>
<td>values identify the geometry: they refer to (the whole of) this and only this geometry</td>
</tr>
</tbody>
</table>
<p>With this information (still to be done) we can for instance</p>
<ul>
<li>either return missing values or generate warnings when a <em>aggregate</em> value at a point location inside a polygon is retrieved, or</li>
<li>list the implicit assumptions made when retrieving attribute values at points inside a polygon when <code>relation_to_geometry</code> is missing.</li>
<li>decide what to do with attributes when a geometry is split: do nothing in case the attribute is constant, give an error or warning in case it is an aggregate, change the <code>relation_to_geometry</code> to <em>constant</em> in case it was <em>identity</em>.</li>
</ul>
<div id="simple-feature-geometries-manipulation" class="section level3">
<h3>Simple feature geometries manipulation</h3>
<p>Simple features can be manipulated including:</p>
<ul>
<li>type transformations (e.g., <code>POLYGON</code> to <code>MULTIPOLYGON</code>)</li>
<li>affine transformation (shift, scale, rotate)</li>
<li>transformation into a different coordinate reference system</li>
<li>geometrical operations, e.g. finding the centroid of a polygon, detecting whether pairs of feature geometries intersect, or find the union (overlap) of two polygons.</li>
</ul>
</div>
<div id="coordinate-reference-systems-conversion-and-transformation" class="section level2">
<h2>Coordinate reference systems conversion and transformation</h2>
<div id="getting-and-setting-coordinate-reference-systems-of-sf-objects" class="section level3">
<h3>Getting and setting coordinate reference systems of sf objects</h3>
<p>The coordinate reference system of objects of class <code>sf</code> or <code>sfc</code> is obtained by <code>st_crs</code>, and replaced by <code>st_crs&lt;-</code>:</p>
<pre class="r"><code>geom = st_sfc(st_point(c(0,1)), st_point(c(11,12)))
s = st_sf(a = 15:16, geometry = geom)
st_crs(s)</code></pre>
<pre><code>## Coordinate Reference System: NA</code></pre>
<pre class="r"><code>s1 = s
st_crs(s1) &lt;- 4326
st_crs(s1)</code></pre>
<pre><code>## Coordinate Reference System:
##   EPSG: 4326 
##   proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot;</code></pre>
<pre class="r"><code>s2 = s
st_crs(s2) &lt;- &quot;+proj=longlat +datum=WGS84&quot;
all.equal(s1, s2)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>an alternative, more pipe-friendly version of <code>st_crs&lt;-</code> is</p>
<pre class="r"><code>s1 %&gt;% st_set_crs(4326)</code></pre>
<pre><code>## Simple feature collection with 2 features and 1 field
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: 0 ymin: 1 xmax: 11 ymax: 12
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
##    a      geometry
## 1 15   POINT (0 1)
## 2 16 POINT (11 12)</code></pre>
</div>
<div id="coordinate-reference-system-transformations" class="section level3">
<h3>Coordinate reference system transformations</h3>
<p>If we change the coordinate reference system from one non-missing value into another non-missing value, the crs is is changed without modifying any coordinates, but a warning is issued that this did not reproject values:</p>
<pre class="r"><code>s3 &lt;- s1 %&gt;% st_set_crs(4326) %&gt;% st_set_crs(3857)</code></pre>
<pre><code>## Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform
## for that</code></pre>
<p>A cleaner way to do this that better expresses intention and does not generate this warning is to first wipe the CRS by assigning it a missing value, and then setting it to the intended value.</p>
<pre class="r"><code>s3 &lt;- s1  %&gt;% st_set_crs(NA) %&gt;% st_set_crs(3857)</code></pre>
<p>To carry out a coordinate conversion or transformation, we use <code>st_transform</code></p>
<pre class="r"><code>s3 &lt;- s1 %&gt;% st_transform(3857)
s3</code></pre>
<pre><code>## Simple feature collection with 2 features and 1 field
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: 0 ymin: 111325.1 xmax: 1224514 ymax: 1345708
## epsg (SRID):    3857
## proj4string:    +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs
##    a                geometry
## 1 15      POINT (0 111325.1)
## 2 16 POINT (1224514 1345708)</code></pre>
<p>for which we see that coordinates are actually modified (projected).</p>
</div>
</div>
<div id="geometrical-operations" class="section level2">
<h2>Geometrical operations</h2>
<p>All geometrical operations <code>st_op(x)</code> or or <code>st_op2(x,y)</code> work both for <code>sf</code> objects as well as <code>sfc</code> objects <code>x</code> and <code>y</code>; since the operations work on the geometries, the non-geometries parts of an <code>sf</code> object are simply discarded. Also, all binary operations <code>st_op2(x,y)</code> called with a single argument, as <code>st_op2(x)</code>, are handled as <code>st_op2(x,x)</code>.</p>
<p>We will illustrate the geometrical operations on a very simple dataset:</p>
<pre class="r"><code>b0 = st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 = b0 + 2
b2 = b0 + c(-0.2, 2)
x = st_sfc(b0, b1, b2)
a0 = b0 * 0.8
a1 = a0 * 0.5 + c(2, 0.7)
a2 = a0 + 1
a3 = b0 * 0.5 + c(2, -0.5)
y = st_sfc(a0,a1,a2,a3)
plot(x, border = &#39;red&#39;)
plot(y, border = &#39;green&#39;, add = TRUE)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-61-1.png" /><!-- --></p>
<div id="unary-operations" class="section level3">
<h3>Unary operations</h3>
<p><code>st_is_valid</code> returns whether polygon geometries are topologically valid:</p>
<pre class="r"><code>b0 = st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 = st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(0,-1), c(-1,-1))))
st_is_valid(st_sfc(b0,b1))</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
<p>and <code>st_is_simple</code> whether line geometries are simple:</p>
<pre class="r"><code>s = st_sfc(st_linestring(rbind(c(0,0), c(1,1))), 
    st_linestring(rbind(c(0,0), c(1,1),c(0,1),c(1,0))))
st_is_simple(s)</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
<p><code>st_area</code> returns the area of polygon geometries, <code>st_length</code> the length of line geometries:</p>
<pre class="r"><code>st_area(x)</code></pre>
<pre><code>## [1] 4 4 4</code></pre>
<pre class="r"><code>st_area(st_sfc(st_point(c(0,0))))</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>st_length(st_sfc(st_linestring(rbind(c(0,0),c(1,1),c(1,2))), st_linestring(rbind(c(0,0),c(1,0)))))</code></pre>
<pre><code>## [1] 2.414214 1.000000</code></pre>
<pre class="r"><code>st_length(st_sfc(st_multilinestring(list(rbind(c(0,0),c(1,1),c(1,2))),rbind(c(0,0),c(1,0))))) # ignores 2nd part!</code></pre>
<pre><code>## [1] 2.414214</code></pre>
</div>
<div id="binary-operations-distance-and-relate" class="section level3">
<h3>Binary operations: distance and relate</h3>
<p><code>st_distance</code> computes the shortest distance matrix between geometries; this is a dense matrix:</p>
<pre class="r"><code>st_distance(x,y)</code></pre>
<pre><code>##           [,1] [,2] [,3]     [,4]
## [1,] 0.0000000  0.6    0 0.500000
## [2,] 0.2828427  0.0    0 1.000000
## [3,] 0.2000000  0.8    0 1.220656</code></pre>
<p><code>st_relate</code> returns a dense character matrix with the DE9-IM relationships between each pair of geometries:</p>
<pre class="r"><code>st_relate(x,y)</code></pre>
<pre><code>##      [,1]        [,2]        [,3]        [,4]       
## [1,] &quot;212FF1FF2&quot; &quot;FF2FF1212&quot; &quot;212101212&quot; &quot;FF2FF1212&quot;
## [2,] &quot;FF2FF1212&quot; &quot;212101212&quot; &quot;212101212&quot; &quot;FF2FF1212&quot;
## [3,] &quot;FF2FF1212&quot; &quot;FF2FF1212&quot; &quot;212101212&quot; &quot;FF2FF1212&quot;</code></pre>
<p>element [i,j] of this matrix has nine characters, refering to relationship between x[i] and y[j], encoded as <span class="math inline"><em>I</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub>, <em>I</em><sub><em>x</em></sub><em>B</em><sub><em>y</em></sub>, <em>I</em><sub><em>x</em></sub><em>E</em><sub><em>y</em></sub>, <em>B</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub>, <em>B</em><sub><em>x</em></sub><em>B</em><sub><em>y</em></sub>, <em>B</em><sub><em>x</em></sub><em>E</em><sub><em>y</em></sub>, <em>E</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub>, <em>E</em><sub><em>x</em></sub><em>B</em><sub><em>y</em></sub>, <em>E</em><sub><em>x</em></sub><em>E</em><sub><em>y</em></sub></span> where <span class="math inline"><em>I</em></span> refers to interior, <span class="math inline"><em>B</em></span> to boundary, and <span class="math inline"><em>E</em></span> to exterior, and e.g. <span class="math inline"><em>B</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub></span> the dimensionality of the intersection of the the boundary <span class="math inline"><em>B</em><sub><em>x</em></sub></span> of x[i] and the interior <span class="math inline"><em>I</em><sub><em>y</em></sub></span> of y[j], which is one of {0,1,2,F}, indicating zero-, one-, two-dimension intersection, and (F) no intersection, respectively.</p>
<p><img src="04_assets/DE9-IM.png" alt="DE9-IM" /> Reading from left-to-right and top-to-bottom, the DE-9IM(a,b) string code is ‘212101212’, the compact representation of <span class="math inline"><em>I</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub> = 2, <em>I</em><sub><em>x</em></sub><em>B</em><sub><em>y</em></sub> = 1, <em>I</em><sub><em>x</em></sub><em>E</em><sub><em>y</em></sub> = 2, <em>B</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub> = 1, <em>B</em><sub><em>x</em></sub><em>B</em><sub><em>y</em></sub> = 0, <em>B</em><sub><em>x</em></sub><em>E</em><sub><em>y</em></sub> = 1, <em>E</em><sub><em>x</em></sub><em>I</em><sub><em>y</em></sub> = 2, <em>E</em><sub><em>x</em></sub><em>B</em><sub><em>y</em></sub> = 1, <em>E</em><sub><em>x</em></sub><em>E</em><sub><em>y</em></sub> = 2</span>. Figure from <a href="https://en.wikipedia.org/wiki/DE-9IM#Illustration">here</a>.</p>
</div>
<div id="binary-logical-operations" class="section level3">
<h3>Binary logical operations:</h3>
<p>Binary logical operations return either a sparse matrix</p>
<pre class="r"><code>st_intersects(x,y)</code></pre>
<pre><code>## Sparse geometry binary predicate list of length 3, where the predicate was `intersects&#39;
##  1: 1, 3
##  2: 2, 3
##  3: 3</code></pre>
<p>or a dense matrix</p>
<pre class="r"><code>st_intersects(x, x, sparse = FALSE)</code></pre>
<pre><code>##      [,1]  [,2]  [,3]
## [1,] TRUE  TRUE  TRUE
## [2,] TRUE  TRUE FALSE
## [3,] TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>st_intersects(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2] [,3]  [,4]
## [1,]  TRUE FALSE TRUE FALSE
## [2,] FALSE  TRUE TRUE FALSE
## [3,] FALSE FALSE TRUE FALSE</code></pre>
<p>where list element <code>i</code> of a sparse matrix contains the indices of the <code>TRUE</code> elements in row <code>i</code> of the the dense matrix. For large geometry sets, dense matrices take up a lot of memory and are mostly filled with <code>FALSE</code> values, hence the default is to return a sparse matrix.</p>
<p><code>st_intersects</code> returns for every geometry pair whether they intersect (dense matrix), or which elements intersect (sparse).</p>
<p>Other binary predicates include (using sparse for readability):</p>
<pre class="r"><code>st_disjoint(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3] [,4]
## [1,] FALSE  TRUE FALSE TRUE
## [2,]  TRUE FALSE FALSE TRUE
## [3,]  TRUE  TRUE FALSE TRUE</code></pre>
<pre class="r"><code>st_touches(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,] FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>st_crosses(s, s, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]
## [1,] FALSE FALSE
## [2,] FALSE FALSE</code></pre>
<pre class="r"><code>st_within(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,] FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>st_contains(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,]  TRUE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>st_overlaps(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2] [,3]  [,4]
## [1,] FALSE FALSE TRUE FALSE
## [2,] FALSE  TRUE TRUE FALSE
## [3,] FALSE FALSE TRUE FALSE</code></pre>
<pre class="r"><code>st_equals(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,] FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>st_covers(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,]  TRUE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>st_covered_by(x, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,] FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>st_covered_by(y, y, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,]  TRUE FALSE FALSE FALSE
## [2,] FALSE  TRUE FALSE FALSE
## [3,] FALSE FALSE  TRUE FALSE
## [4,] FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>st_equals_exact(x, y,0.001, sparse = FALSE)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]
## [1,] FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE</code></pre>
</div>
<div id="operations-returning-a-geometry" class="section level3">
<h3>Operations returning a geometry</h3>
<pre class="r"><code>u = st_union(x)
plot(u)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-70-1.png" /><!-- --></p>
<pre class="r"><code>par(mfrow=c(1,2), mar = rep(0,4))
plot(st_buffer(u, 0.2))
plot(u, border = &#39;red&#39;, add = TRUE)
plot(st_buffer(u, 0.2), border = &#39;grey&#39;)
plot(u, border = &#39;red&#39;, add = TRUE)
plot(st_buffer(u, -0.2), add = TRUE)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-71-1.png" /><!-- --></p>
<pre class="r"><code>plot(st_boundary(x))</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-72-1.png" /><!-- --></p>
<pre class="r"><code>par(mfrow = c(1:2))
plot(st_convex_hull(x))
plot(st_convex_hull(u))</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-73-1.png" /><!-- --></p>
<pre class="r"><code>par(mfrow = c(1,1))</code></pre>
<pre class="r"><code>par(mfrow=c(1,2))
plot(x)
plot(st_centroid(x), add = TRUE, col = &#39;red&#39;)
plot(x)
plot(st_centroid(u), add = TRUE, col = &#39;red&#39;)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-74-1.png" /><!-- --></p>
<p>The intersection of two geometries is the geometry covered by both; it is obtained by <code>st_intersection</code>:</p>
<pre class="r"><code>plot(x)
plot(y, add = TRUE)
plot(st_intersection(st_union(x),st_union(y)), add = TRUE, col = &#39;red&#39;)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-75-1.png" /><!-- --></p>
<p>To get <em>everything but</em> the intersection, use <code>st_difference</code> or st_sym_difference`:</p>
<pre class="r"><code>par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(x, col = &#39;#ff333388&#39;); 
plot(y, add=TRUE, col=&#39;#33ff3388&#39;)
title(&quot;x: red, y: green&quot;)
plot(x, border = &#39;grey&#39;)
plot(st_difference(st_union(x),st_union(y)), col = &#39;lightblue&#39;, add = TRUE)
title(&quot;difference(x,y)&quot;)
plot(x, border = &#39;grey&#39;)
plot(st_difference(st_union(y),st_union(x)), col = &#39;lightblue&#39;, add = TRUE)
title(&quot;difference(y,x)&quot;)
plot(x, border = &#39;grey&#39;)
plot(st_sym_difference(st_union(y),st_union(x)), col = &#39;lightblue&#39;, add = TRUE)
title(&quot;sym_difference(x,y)&quot;)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-76-1.png" /><!-- --></p>
<p>Function <code>st_segmentize</code> adds points to straight line sections of a lines or polygon object:</p>
<pre class="r"><code>par(mfrow=c(1,3),mar=c(1,1,0,0))
pts = rbind(c(0,0),c(1,0),c(2,1),c(3,1))
ls = st_linestring(pts)
plot(ls)
points(pts)
ls.seg = st_segmentize(ls, 0.3)
plot(ls.seg)
pts = ls.seg
points(pts)
pol = st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0))))
pol.seg = st_segmentize(pol, 0.3)
plot(pol.seg, col = &#39;grey&#39;)
points(pol.seg[[1]])</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-77-1.png" /><!-- --></p>
<p>Function <code>st_polygonize</code> polygonizes a multilinestring, as far as the points form a closed polygon:</p>
<pre class="r"><code>par(mfrow=c(1,2),mar=c(0,0,1,0))
mls = st_multilinestring(list(matrix(c(0,0,0,1,1,1,0,0),,2,byrow=TRUE)))
x = st_polygonize(mls)
plot(mls, col = &#39;grey&#39;)
title(&quot;multilinestring&quot;)
plot(x, col = &#39;grey&#39;)
title(&quot;polygon&quot;)</code></pre>
<p><img src="04_Spatial_with_sf_files/figure-html/unnamed-chunk-78-1.png" /><!-- --></p>
<p>Further reading:</p>
<ol style="list-style-type: decimal">
<li>S. Scheider, B. Gräler, E. Pebesma, C. Stasch, 2016. Modelling spatio-temporal information generation. Int J of Geographic Information Science, 30 (10), 1980-2008. (<a href="http://pebesma.staff.ifgi.de/generativealgebra.pdf">pdf</a>)</li>
<li>Stasch, C., S. Scheider, E. Pebesma, W. Kuhn, 2014. Meaningful Spatial Prediction and Aggregation. Environmental Modelling &amp; Software, 51, (149–165, <a href="http://dx.doi.org/10.1016/j.envsoft.2013.09.006">open access</a>).</li>
</ol>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>R Bivand (2011) <a href="http://geostat-course.org/system/files/monday_slides.pdf">Introduction to representing spatial objects in R</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Coordinates should be of type double and will be promoted if not.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>E. Pebesma &amp; R. Bivand (2016)<a href="http://pebesma.staff.ifgi.de/pebesma_sfr.pdf">Spatial data in R: simple features and future perspectives</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</div>

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2684666-2', 'auto');
  ga('send', 'pageview');
</script>

<!-- disqus -->
<div id="disqus_thread" class="standardPadding"></div>
<script type="text/javascript" src="js/disqus.js"></script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<!-- disqus 
<div id="disqus_thread" style="margin-top: 45px;"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'rdataanalysis'; // required: replace example with your forum shortname
        var disqus_identifier = "{{ page.url }}";
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq         );
        })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">
              comments powered by Disqus.</a>
</noscript>
-->

<!-- give the footer some space -->
<br/>
<br/>

<footer id="site-footer">
  <div id="footer1">
  <a href="http://www.adamwilson.us"><img src="img/wilson.png" alt="logo" width=40px></a>
  <a href="http://adamwilson.us/#contact"><i class="fa fa-envelope fa-2x"></i></a> 
  <a href="https://twitter.com/AdamWilsonLab"><i class="fa fa-twitter fa-2x"></i></a> 
  <a href="https://github.com/AdamMWilson"><i class="fa fa-github fa-2x"></i></a>
  </div>
  <div id="footer2">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
  </div>
</footer>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>


</body>
</html>
